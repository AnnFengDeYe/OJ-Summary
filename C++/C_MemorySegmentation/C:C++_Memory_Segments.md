

# 补充知识： 内存和程序

计算机的内存由一系列有序的字节构成，用来存储程序和程序所操作的数据。可以把内存看成计算机执行程序的工作区域。一个程序和它的数据必须装入内存中，才能被CPU执行。每个字节在内存中都有一个唯一的地址，地址用来存储和查找数据时定位字节的位置。由于内存中字节可以按照任意顺序进行读取，所以内存又称为**随机存储器（Random-Access Memory, 随机存取存储器）**。

从硬件角度来看，内存就是一片巨大连续且可随机访问的字节海洋。但是，如果软件层面不对内存进行分区，那么就会造成混乱：代码指令可能会被当成数据意外改写，关键的变量也可能被无意中覆盖。所以，**编译器、链接器和操作系统**联手为程序制定了一套严谨的内存划分规则。它们会将程序的**虚拟地址空间**（也就是程序视角中的内存）划分成若干个具有不同功能和生命周期的逻辑区域。也就是本期视频的主角**C++内存布局（Memory Layout）**或**内存分段（Memory Segmentations）**。

**源代码 (.cpp)** ➡️ **[预处理器]** ➡️ **预处理后的代码 (.i)** ➡️ **[编译器]** ➡️ **汇编代码 (.s)** ➡️ **[汇编器]** ➡️ **目标代码 (.o)** ➡️ **[链接器]** + **[库文件]** ➡️ **可执行文件 (.exe)** ➡️ **[操作系统加载]** ➡️ **运行**

```
      +-----------------------+  <-- 高内存地址
      |   Command Line Args   |
      |   & Environment Vars  |
      +-----------------------+
      |                       |
      |         Stack         |  // 存储局部变量、函数参数
      |           ⬇           |  // 向低地址方向增长
      +-----------------------+
      |                       |
      |          ...          |  // 栈与堆之间的巨大空闲区域
      |                       |
      +-----------------------+
      |           ⬆           |  // 向高地址方向增长
      |          Heap         |  // 用于动态内存分配 (new, malloc)
      |                       |
      +=======================+  <-- 动态内存与静态内存分界
      |     BSS Segment       |  // 所有被初始化为零或未被显式初始化的全局/静态变量
      +-----------------------+
      |     Data Segment      |  // 已初始化的全局/静态变量
      +-----------------------+
      |  .rodata Segment      |  // ★ 存放字符串字面量、const常量
      +-----------------------+
      |   Text (Code) Segment |  // 存放程序代码 (只读)
      +-----------------------+  <-- 低内存地址
```

# scene 1 引例: 植物大战僵尸关卡游戏开发

你现在是《植物大战僵尸》游戏的新人开发者，已经完成了某个关卡的第一版代码，但是在初步测试后你发现了三个问题。

* **第一个问题：后期卡顿。** 关卡后期，随着僵尸数量越来越多，游戏会变得异常卡顿，频繁掉帧。
* **第二个问题：技能闪退。** 如果在某块僵尸密度很高的草地上，植物倭瓜使用其必杀技泰山压顶后，游戏就会闪退。 
* **第三个问题：平衡性难调。** 一些植物或者僵尸的数值属性不太合理影响了游戏的平衡性，你需要频繁的在浩如烟海的代码文件中修改对应的数值，因为你采用了硬编码。

**经过排查，你找到了问题的根源：**

**后期卡顿**，其根源在于**“内存碎片化”**。当大量不同大小的对象在堆内存中被反复创建和销毁时，内存空间就会变得七零八落。这导致后续内存分配的效率降低。更关键的是，它严重破坏了**CPU缓存的局部性原理**，使得CPU无法高效地从内存中读取数据，性能急剧下降，最终导致画面掉帧。

**游戏闪退**，元凶则是**“栈溢出”（Stack Overflow）**。在实现倭瓜范围伤害的函数里，不恰当地使用了递归。在高密度僵尸潮中，一个伤害效果可能会触发一个极深的**链式调用**。每一次函数调用都会在栈上创建一个**栈帧（Stack Frame）**，当调用链过深，就会撑爆有限的栈空间，导致程序崩溃。

最后，为了解决硬编码问题，你决定采用**数据驱动**的现代游戏开发架构，核心是**数据与代码分离**。在这种架构下：**负责游戏逻辑的代码**，在编译后生成机器指令，运行时被加载到内存的**代码段（Code Segment）**。**而游戏数值**，则从外部的**配置文件**中读取。游戏启动后，程序会解析这些文件，并将数据加载到**堆内存（Heap）**中，供逻辑代码随时调用。这样，策划只需要修改配置文件就能调整游戏平衡，完全无需修改代码和重新编译，极大地提升了开发效率。

也许你现在对于内存中的堆、栈、静态内存区这些概念还不够了解，也能完成程序的开发。但是充分理解内存布局，可以让你在软件开发时，从源头上规避掉各种诡异的BUG。

-------



------

# scene 2 内存布局/内存分段总览

程序的内存空间（RAM中的**虚拟地址空间**）主要由三大区域构成：**代码段**、**静态数据区**、**动态数据区**。其中，代码段又称文本段（.text），静态数据区进一步细分为**只读数据段(.rodata)**、**数据段(.data)**以及.bss段（Block Started by Symbol）。**只读数据段(.rodata)**存放已初始化的只读常量；**数据段(.data)**存放已初始化的非零变量；而 **.bss段** 则为所有未初始化或值为零的变量预留空间。动态数据区可以分为堆和栈。

注意，这里的代码段与静态数据区的段名（.text, .text, .text, .bss）均以点为前缀，这是因为它们是在**编译链接阶段**就已确定的可执行文件中的具名段。该命名约定起源自汇编器，用以标记这些由**构建工具链**管理的特殊名称（在macOS上则是以双下划线为前缀）。而堆和栈是纯粹的**运行时内存区域（Runtime Memory Regions）**，在可执行文件中并无对应的具名段，因此不以点或者双下划线为前缀命名。

在程序的**虚拟地址空间**中，自低地址向高地址方向，传统的布局设计依次为：代码段（.text）、只读数据段（.text）、数据段（.text）、BSS段（.bss），以及紧随其后的堆。而栈则位于地址空间的最顶端。为实现空间的最大化利用，**堆自低地址向上生长，栈自高地址向下生长**，两者共享并动态划分中间的可用内存区域。

----

# scene 3 文本段和静态数据区

文本段和静态数据区在**程序编译链接时**就已经确定，并占用一块固定大小的内存空间。文本段和静态数据区由**编译器**自动进行分配和释放，程序员无需也无法手动干预。

其中的文本段，也称代码段，存放源代码经过编译后的对应CPU指令，即机器码。**其内容由可执行文件加载而来，其大小在编译链接阶段便已确定，在程序整个运行期间保持不变，并被操作系统赋予**只读（Read-Only）**权限，以确保CPU能安全地读取并执行程序逻辑。**

我们以一个简单的加法运算代码作为源程序，编译链接后得到执行体main1

```C++
int main() {
    int a = 10, b = 20;
    return a + b;
}
```

可以使用objdump终端命令查看一个文本段的内存信息：

```
objdump -h main1
```

```
Sections:
Idx Name          Size     VMA              Type
  0 __text        0000002c 0000000100003f7c TEXT
  1 __unwind_info 00000058 0000000100003fa8 DATA
```

也可以使用使用参数`-d` 选项进行反汇编disassemble，得到文本段的机器码

```
objdump -d main1
```

```
0000000100003f7c <_main>:
100003f7c: d10043ff     sub     sp, sp, #16
100003f80: b9000fff     str     wzr, [sp, #12]
100003f84: 52800148     mov     w8, #10
100003f88: b9000be8     str     w8, [sp, #8]
100003f8c: 52800288     mov     w8, #20
100003f90: b90007e8     str     w8, [sp, #4]
100003f94: b9400be8     ldr     w8, [sp, #8]
100003f98: b94007e9     ldr     w9, [sp, #4]
100003f9c: 0b090100     add     w0, w8, w9
100003fa0: 910043ff     add     sp, sp, #16
100003fa4: d65f03c0     ret
```

静态数据区有三个分段，对于bss段，全称为**Block Started by Symbol，存放所有未初始化或初始化为零的全局/静态变量**其大小在编译时确定，且在运行时可读可写。

bss的核心设计理念之一是**只在内存中预留位置，但不在文件中保存实体**。即编译器在生成可执行文件时，并不会将这些变量的大量零值实实在在地写入文件，而仅仅是记录下它们的名称、大小等元信息。当操作系统加载程序时，它会读取这些元信息，在内存中预留出相应空间，并将其全部置零。这样做的好处是为大型未初始化数据节省磁盘空间，比如未初始化或者初始化为0的大型数组。

```C++
int global_bss_A; 							
int global_bss_B = 0;  				
static int global_bss_C; 					
static int global_bss_D = 0;  				
int global_bss_array_E[4096];
int global_bss_array_F[4096] = {0};
int main()
{
    static int local_bss_G; 				  
    static int local_bss_H = 0; 		  
    static int local_bss_array_I[128];
    static int local_bss_array_J[128] = {0};
}
```

让我们反汇编源程序看一下具体bss段的实例吧

在macOS on ARM64的编译环境下，利用objdump命令，可以看到编译器将非静态的未初始化/零初始化全局变量放入了`__common`段，而将静态的未初始化/零初始化变量放入了`__bss`段。这两个段都属于BSS的范畴。

计算出的非静态变量总大小为 **32776字节**，等于`__common`段的大小 (`0x8008` = 32776)。计算出的静态变量总大小为 **1032字节**，等于`__bss`段的大小 (`0x408` = 1032)。

**非静态 (non-static) 变量**:

- `global_bss_A`: 4 字节
- `global_bss_B`: 4 字节
- `global_bss_array_E`: 4096 * 4 = 16384 字节
- `global_bss_array_F`: 4096 * 4 = 16384 字节
- **总计**: 4 + 4 + 16384 + 16384 = **32776 字节**

**静态 (static) 变量 (包括全局和局部)**:

- `global_bss_C`: 4 字节
- `global_bss_D`: 4 字节
- `local_bss_G`: 4 字节
- `local_bss_H`: 4 字节
- `local_bss_array_I`: 128 * 4 = 512 字节
- `local_bss_array_J`: 128 * 4 = 512 字节
- **总计**: 4 + 4 + 4 + 4 + 512 + 512 = **1032 字节**



对于初始化数据区。程序加载时，这块区域的大小**构建阶段**就已经被完全确定下来，并且这个大小会从可执行文件中直接复制到内存。根据**能否在运行时修改**的属性，该区域可分为可读写的.data段和只读的.rodata段。

**.data 段**。它存放的是所有**初始值不为零**的全局变量和静态变量。因为它们是‘变量’，所以这块内存区域在程序运行时是**可读可写**的。**.rodata 段**，存放**常量数据**。即用const修饰的变量和字符串字面量。这块内存会被操作系统保护起来，变成**只读**状态。任何试图修改它的行为都会直接导致程序崩溃。同样也可以使用objdump对这段代码进行反汇编分析，这里不再重读，有兴趣的小伙伴可以自行尝试。

```C++
int global_data_A = 1;
static int global_data_B = 2;
int global_data_C_array[3] = {10, 20, 30};

const int global_rodata_D = 100;
static const int global_rodata_E = 200;

int main()
{
    static int local_data_F = 3;
  
    static const int local_rodata_G = 4;
}
```



# scene 4 动态数据区

动态内存区在**程序运行时**进行分配。

其中的栈（Stack）是一块由编译器进行自动化管理的区域，用于局部变量的存储和函数调用。它遵循严格的“后进先出”（LIFO）数据结构原则。当函数被调用时，其对应的栈帧（一个包含该函数所有局部变量、参数和返回地址等信息的内存块）被压入栈顶；当函数返回时，栈帧被整体弹出，其所占内存瞬间被回收。这种自动化的管理机制使得栈的内存分配和释放速度极快，且从根本上杜绝了内存泄漏的可能。然而，它的缺点是空间大小在编译时已固定且通常较小，并且其上所有数据的生命周期都被严格限制在函数的作用域内。

```C++
#include <stdio.h>

int factorial(int n) {
    if (n == 0 || n == 1) { // base case
        return 1; 
    }

    return n * factorial(n - 1);
}

int main() {
    int number = 3;
    int result = factorial(number);
}
```

注意，对于递归代码必须要有可以收敛的基线条件，也就是递归的终点，否则会导致无限递归，发生栈溢出 stack overflow错误。

**堆**是用于**动态分配**的内存区，它提供了**巨大且灵活的空间**，可以由程序员**手动申请和管理**。但是主动申请的内存一旦忘记释放，就会导致内存泄漏。在C语言中，你可以使用malloc和free进行内存的申请和释放。在C++中，则对应new和delete。

**组织堆内存的方式，是连续还是分散，对程序性能会有影响**。

原因在于CPU缓存**。CPU在读取内存时，会一次性地将目标数据及其“邻居”一同加载到高速缓存中。因此，当遍历**连续内存**（如vector）时，下一个元素大概率已在缓存中，这叫“缓存命中”，速度极快。而遍历**分散内存（如list）时，访问下一个节点需要重新去主内存读取，这叫缓存缺失，速度会相对较慢。

比如这段代码中，同等数量下，连续内存的vector在遍历时会比分散内存存储的链表更快。

# scene 5 地址空间布局随机化 (Address Space Layout Randomization, ASLR)

现在我们已经对C/C++内存布局中每一个分段都有了足够的了解，最后我们来看一下在一个程序内运行时它们的相对地址顺序。

这个全家福代码将会打印内存布局中的每一个分段的十六进制起始地址。

```C++
#include <iostream>

void function_for_text_segment() {}
const int g_rodata_var = 10;
int g_data_var = 20;
int g_bss_var;

int main(int argc, char* argv[]) {

    int* heap_ptr = new int(30);

    // ===== 打印所有核心区域的内存地址 =====
    std::cout << "--- Memory Layout Analysis ---" << std::endl;
    uintptr_t text_addr   = (uintptr_t)function_for_text_segment;
    uintptr_t rodata_addr = (uintptr_t)&g_rodata_var;
    uintptr_t data_addr   = (uintptr_t)&g_data_var;
    uintptr_t bss_addr    = (uintptr_t)&g_bss_var;
    uintptr_t heap_addr   = (uintptr_t)heap_ptr;
    uintptr_t stack_addr  = (uintptr_t)&argv[0];

    std::cout << "1. .text address:    0x" << std::hex << text_addr << std::endl;
    std::cout << "2. .rodata address:  0x" << std::hex << rodata_addr << std::endl;
    std::cout << "3. .data address:    0x" << std::hex << data_addr << std::endl;
    std::cout << "4. .bss address:     0x" << std::hex << bss_addr << std::endl;
    std::cout << "5. Heap address:     0x" << std::hex << heap_addr << std::endl;
    std::cout << "6. Stack address:    0x" << std::hex << stack_addr << std::endl;
    std::cout << std::dec << std::endl;

    // ===== 验证与 ASLR =====
    std::cout << "--- Layout & ASLR Verification ---" << std::endl;

    // Part 1: 验证静态内存区内部的固定布局
    // 这个顺序是由链接器决定的，不受ASLR影响，结果始终为 true。
    std::cout << std::boolalpha;
    std::cout << "Static Area Rule (.text < .rodata < .data < .bss) Check: "
              << ((text_addr < rodata_addr) && (rodata_addr < data_addr) && (data_addr < bss_addr))
              << std::endl << std::endl;

    // Part 2: 观察各大区域间的相对位置
    // 这个顺序受 ASLR 影响，在不同系统或多次运行中可能不同。
    std::cout << "Major Areas Relative Position (can be randomized by ASLR):" << std::endl;
    std::cout << "  Heap < Stack ?     " << (heap_addr < stack_addr) << std::endl;
    std::cout << "  Static memory < Heap ?     " << (bss_addr < heap_addr) << std::endl;
    std::cout << std::endl;

    delete heap_ptr;
    return 0;
}
```

这是我们第一次运行的结果。先看静态内存区，从.text到.bss，地址确实是从小到大依次排列的，即按照地址高低排序，`代码段(.text) < 只读数据区段(.rodata) < 数据段(.data) < BSS段(.bss)`。

我们再次运行代码，发现所有区域的**基地址都发生了改变**。这正是现代操作系统的安全卫士——**地址空间布局随机化（Address Space Layout Randomization,ASLR）**。

ASLR就像操作系统在每次运行程序前，都帮你“洗一次牌”，随机化内存区域的起始地址。这样一来，程序的内存地址只在单次运行时固定，黑客便无法依赖固定的地址进行攻击，极大提升了安全性。

但是，ASLR也并非完全无序。通过多次代码实验，栈的起始地址总是小于堆的起始地址，而静态区的起始地址永远小于堆和栈。这是否意味着前面所讲的栈 > 堆 > 静态区的模型是错的呢？并非错误，而是模型背后的**设计哲学已经演变了**。

因为教科书的时代，是32位系统的旧时代：虚拟地址空间一般只有4GB，设计者让**栈从最高地址向下生长，堆从静态区之上向上生长**。这样他们之前的剩余空间就可以尽可能的多，但是当内存使用过多时，他们还是可能相撞造成内存不足。

然而在现代的**64位系统**中，虚拟地址空间大到近乎无限。‘撞车’的风险已不复存在。因此，操作系统获得了更大的自由度，不再需要32位那样紧凑的设计。ASLR会分别在几个宏观的地址范围内进行随机化：**静态内存区**被随机放置在一个相对**较低**的地址范围。**堆和栈**则被分别随机放置在**更高**的地址范围。这就是为什么代码结果观察到静态区的地址总是最小。由于虚拟空间足够巨大，堆和栈之间有广阔的安全隔离带，它们永远不可能相遇。这种以空间换取安全性和降低内存复杂性的布局，正是现代操作系统的选择。



```
      ▲ 高地址 (High Address)
      │
      │
  +-------------------------------------------------+
  |   堆区 (Heap)                                   |
  |   ● 起始地址 @ 0x600000578020                    |  <--+
  |   ● (向上增长 ⬆)                                |     |
  +-------------------------------------------------+     |
      │                                                   | (ASLR 随机化)
      │ ... 巨大的虚拟地址空间 ...                          |
      │                                                   |
  +-------------------------------------------------+     |
  |   栈区 (Stack)                                  |     |
  |   (内部顺序固定 ⬇)                              |  <--+
  |    - 参数 (argc) @ 0x16f443418                  |
  |    - 参数 (argv) @ 0x16f443410                  |
  |    - 局部变量    @ 0x16f44340c                  |
  |    (向下增长 ⬇)                                |
  +-------------------------------------------------+
      │                                                   |
      │ ... 巨大的虚拟地址空间 ...                          |
      │                                                   |
  +-------------------------------------------------+     |
  |   静态区域 (Static Area)                        |     |
  |   (内部顺序固定 ⬆)                              |  <--+ (ASLR 决定了这整个
  |    - BSS段  (阳光)  @ 0x1009c8000               |       “静态块”的起始位置)
  |    - 数据段 (图鉴)  @ 0x1009c37e8               |
  |    - 代码段 (main) @ 0x1009be5a4                |
  +-------------------------------------------------+
      │
      ▼ 低地址 (Low Address)
```

