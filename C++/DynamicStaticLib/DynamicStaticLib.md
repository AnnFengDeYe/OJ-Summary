# C/C++程序的一生 | 从构建到运行 | 彻底搞懂静态/动态链接

# scene 1 程序生命周期概述

C或C++源代码若要成为一个能在计算机上运行的程序，必须经历一个完整的生命周期。这个生命周期将人类可读的源代码，系统性地转化为CPU能够执行的二进制指令。（人）

这个过程主要由**预处理(Preprocessing)、编译(Compilation)、汇编(Assembly)、链接(Linking)、加载(Loading)**以及**CPU执行(Execution)**六个阶段构成。

这六个阶段可以被归纳为两大环节：构建(Build)与运行(Run)。其中，**预处理、编译、汇编和链接**这前四个步骤共同组成了构建阶段，此阶段的收尾步骤是链接，链接器(Linker)会解析所有目标代码，将程序所需的**静态库**（`.lib`, `.a`）的代码**复制并嵌入**到最终产物中；与此同时，它会为程序所需的**共享库**（**动态库**）（`.dll`, `.so`）**记录下引用标记**。所有这些部分最终被组装成一个完整的**可执行文件**。

当用户启动该可执行文件时，便进入运行阶段，操作系统的加载器(Loader)会将该可执行文件以及所需的共享库(.dll, .so)从硬盘载入内存；最终，CPU开始逐条执行内存中的机器指令，接收外部输入(Input)并产生相应输出(Output)，完成程序的整个执行过程。

# 构建阶段

## scene 2 Preprocessing

首先来看**预处理 (Preprocessing)**阶段，预处理器相当于一个文本处理器，负责嵌入#include的头文件内容、展开由#define定义的宏、移除注释并解析条件编译指令，最终生成一个不含任何预处理指令的纯净源代码文件。

可以在linux系统中使用g++得到预处理后的代码，在macOS中更推荐直接使用clang++，因为g++在macOS中是clang++的别名。

本次分享中出现的所有终端命令，g++和clang++无论在Linux还是MacOS都是可以相互替换的。

其中 -E 选项告诉编译器进行预处理，E是expand的首字母，对应预处理的功能将头文件和宏展开。

- **G++**: g++ -E main.cpp -o main.i
- **Clang++**: clang++ -E main.cpp -o main.i

正因为预处理的核心任务之一是查找并包含文件，所以该阶段最常见的错误便是No such file or directory（包含了不存在了文件）。



## scene 3 Compiling

其次是**编译 (Compilation)**阶段，该阶段编译器会对预处理阶段得到的纯净源代码文件进行词法、语法和语义分析，在检查无误后，将代码优化并翻译成特定目标平台的**汇编代码**。 `main.i` -> `main.s`

可以通过g++命令的-S选项来得到这一阶段的产物，可以选择从上一步的.i生成汇编代码，也可以直接从源码生成汇编代码：

- **G++**: g++ -S main.i -o main.s (从 .i 文件生成) 
- 或 g++ -S main.cpp -o main.s (直接从源文件生成)
- **Clang++**: clang++ -S main.cpp -o main.s

编译阶段的常见错误是各种语法和语义错误，比如变量命名中的不合法字符，缺少分号等。

## scene 4 Assembling

编译之后是**汇编 (Assembly, as)**阶段，汇编器（assembler）将上一阶段生成的汇编代码翻译成机器码，即 CPU 能够直接执行的二进制指令，并将这些指令和相关数据打包成一种标准格式的文件，即目标文件（object file），通常以.o作为后缀

使用 -c 选项进行汇编。这里的c是compile的缩写，你可能会觉得奇怪，既然是在Assembly阶段，为什么命令选项却是compile的首字母c呢？这是一个历史遗留的术语习惯，在早期的C语言工具链中，**狭义的 Compile**指从源代码 (.c/.cpp) 到汇编代码 (.s) 的过程。**广义的 Compile**指从源代码 (.c/.cpp) 到目标文件 (.o) 的**整个过程**，包含了预处理、狭义编译、汇编三个步骤。这里的**-c** **选项的意义广义的compile。**

- **G++**: g++ -c main.s -o main.o (从 .s 文件生成) 
- 或 g++ -c main.cpp -o main.o (直接从源文件生成)
- **Clang++**: clang++ -c main.cpp -o main.o

注意这里的二进制目标文件不再是文本文件，因此不能直接查看其内容，但是可以通过反汇编指令**objdump -d main.o**，将.o文件中的二进制机器码翻译回人类可读的汇编代码。可以看到，相比于.s的汇编代码，这个反汇编.o出来的代码是带有**具体地址偏移的二进制机器码**，**丢失了所有原始的注释以 ; 符号开头和汇编伪指令(以 . 符号开头)。**

由于汇编阶段是编译后.s文件的直接翻译，因此不会有任何错误，因为如果有错误，编译器就一定会在上一个阶段暴露出来。

## scene 5 Linking

Assembly之后是**链接 (Linking)**阶段，链接器 (linker) 将目标文件与所需的静态库进行合并，通过**符号解析**（将函数调用与其实际定义匹配）和**地址重定位**（为代码和数据分配最终的内存地址），最终生成一个单一的、完整的可执行文件（例如 Linux 的 **ELF**、或 Windows 的 exe）。

注意：在**链接时 (Link-Time)**，链接器将被用到的代码**完整地**从静态库（`.a`/`.lib`）中**复制**并**嵌入**到最终的**可执行文件**中。这会生成一个体积较大、但完全**自包含 (Self-Contained)** 的程序，它在**运行时不依赖**任何外部库文件。

静态链接时最常见的错误，是链接器在提供的所有 `.o` 和 `.a` 文件中找不到某个函数或变量的‘实现体’，这会直接导致 `Undefined Symbols` 或 `Undefined References` 报错。

**此外**，当手动使用 `g++` 构建工程时，一个常见的陷阱是**库的链接顺序**。由于链接器通常是**单向扫描**依赖的，**如果库 A 依赖库 B，那么库 B 必须出现在库 A 的后面**。例如，`g++ main.o -lA -lB` 是正确的顺序；反之，如果写成 `g++ main.o -lB -lA`，链接器在处理库 A 时，就无法解析其对库 B 的依赖，从而抛出 `undefined reference` 错误（修）。

# scene 6 静态库/链接

现在来演示一下具体的静态库链接实操。（人）

代码实例 (`StaticDemo_1`) 中，主函数 `main.cpp` 依赖于 `my_add` 和 `my_multiply` 这两个功能模块。这两个模块自身是相互独立的。需要将这两个功能模块打包为静态库再将main函数和这个打包后的静态库进行链接。

首先使用-c选项，将功能模块（`my_add.cpp` 和 `my_multiply.cpp`）和主程序main.cpp这三个源代码文件都编译成目标文件（`.o`）。

```
g++ -c my_add.cpp my_multiply.cpp main.cpp
```

接着使用 `ar` (archiver，归档器) 命令将这些 `.o` 文件“打包”成一个静态库。静态库的标准的命名规范是 `lib<name>.a`。这里命名为 `libmymath.a`。

```
ar rcs libmymath.a my_add.o my_multiply.o
```

这里的 rcs 是三个选项组合在了一起，其中r (Replace)表示替换库中已有的同名 .o 文件； c (Create)表示如果库不存在，就创建它，s (Symbol)创建一个符号索引，这能加快后续的链接速度。你可能会好奇为什么这个ar命令的选项参数没有-符号，这是因为ar命令属于上古遗留，**在 POSIX 和 GNU 规范（即用 `-` 和 `--`）统一天下之前**就已经存在的“活化石”，而大一统之后的现代命令工具（如g++）都会有-作为命令选项的前缀。

然后进行静态链接<code>.o</code> 和 <code>.a</code> 得到可执行文件。链接器会读取 `main.o`，发现它需要 `add` 和 `multiply` 函数。然后链接器会去 `libmymath.a` 中查找这两个函数，**将它们的实现代码“复印”出来，并嵌入到最终的执行体 `my_program` 中。**

```
g++ main.o libmymath.a -o my_program
```

**现在目录中会生成可执行文件** `my_program`且可以得到正确的运行结果

最后来证明一下前面所说的静态链接得到的可执行文件是静态库的完整复制和嵌入，只需要证明 `my_program` 执行体在运行时不再需要构建过程中产生的静态库`libmymath.a`，当然也不需要任何 `.o` 文件。

现在当前目录会有这些文件： `my_program` (可执行文件) `libmymath.a` (静态库) `main.o` `my_add.o` `my_multiply.o` (目标文件) `.cpp` 和 `.h` (源码)。**删除所有“构建产物”，即静态库.a和目标文件.o**，删除后的当前目录中只剩下源码（`.cpp`/`.h`）和最终的可执行文件 `my_program`。

```
# 删除静态库./
rm libmymath.a

# 删除所有目标文件
rm main.o my_add.o my_multiply.o
```

**程序依然可以成功运行**

```
./my_program
```

可以证明，`my_program` 在运行时没有以任何方式去查找 `libmymath.a` 或任何 `.o` 文件，因为它所需要的所有代码（`add` 和 `multiply` 的具体实现）已经被**完整地复制**并**内嵌**到执行体内部了。



有兴趣的同学可以自行尝试一下库A依赖库B的这种带有依赖的静态库链接，案例代码StaticDemo_2和操作命令讲解文稿我会放在我的github仓库中，这里不再赘述。如果你发现命令参数顺序和依赖无关，比如`g++ main.o libB.a libA.a` 也能成功链接，那么这是现代链接器优化的结果。但是在一些版本较旧的Linux发行版或嵌入式开发中，不遵循正确的依赖顺序就会导致链接失败。



再来看一个带有相互依赖的例子，库A依赖库B，和前面一样，首先将所有 `.cpp` 编译为 `.o`

```
g++ -c main.cpp libA.cpp libB.cpp
```

现在你的目录中会多出三个文件：`main.o`, `libA.o`, `libB.o`。

将 `libA.o` 和 `libB.o` 分别打包成各自的静态库。

```
# 创建 libA.a
ar rcs libA.a libA.o

# 创建 libB.a
ar rcs libB.a libB.o
```

错误的链接顺序，把最底层的依赖 `libB.a` 放在 `libA.a` *之前*。

```
g++ main.o libB.a libA.a -o my_program
```

将会看到链接失败，并收到一个错误：

```
undefined reference to `funcB()'
```

严格按照依赖顺序（`main.o` 必须在最前，`libA.a` 在中间，`libB.a` 在最后）。

```
g++ main.o libA.a libB.a -o my_program
```

链接成功，成功生成了可执行文件my_program。

```
rm *.o *.a my_program
```



**注意**：链接器（g++命令）对**命令行参数**（例如 `libA.a`, `libB.a`）是单向扫描的。

但链接器对**单个归档文件（`.a` 库）的内部**是会**循环扫描**的，直到在这个库中再也找不到可以解析的符号为止。

利用这个特性，可以将有内部依赖关系的 `libA.o` 和 `libB.o`打包进同一个库，以规避它们之间的顺序问题：

```
ar rcs libmylib.a libA.o libB.o
```

这里的`ar` 命令只是一个**归档工具（Archiver）**，**不会**去检查 `libA.o` 是否依赖 `libB.o`，因此命令中的顺序是不重要的。它只是打包文件和创建索引。无论是先归档 `libA.o` 还是 `libB.o`，最终的索引内容都是一样的。

然后再进行链接：

```
g++ main.o libmylib.a -o my_program
```

这个命令可以链接成功，并生成可执行文件 `my_program`。因为 `libmylib.a` 内部的循环扫描机制会自动处理 `libA.o` 对 `libB.o` 的依赖（反之亦然）。

但是仍然需要注意，`main.o` 仍然需要放在它所依赖的 `libmylib.a` 的**最前面**。因为链接器的对命令行参数是单向扫描的。链接器必须先通过 `main.o` 获知程序“需要哪些符号”，然后才能在后续的 `libmylib.a` 中去“寻找并解析”这些符号。

# scene 7 运行阶段

构建期间的阶段已经全部完成，现在我们来到了运行时的加载 (Loading) 阶段，**在程序运行时**，操作系统的**动态加载器 (Dynamic Loader)** 会解析可执行文件中的“引用标记”，这是链接器在构建时留在可执行文件中的一个“占位符”，表明程序需要一个来自外部动态库的函数。

随后，加载器会在系统中查找所需的动态库（例如 `.so`、`.dll` 或 `.dylib`），并将它们**加载**到进程的内存空间中。**注意，动态库在构建时（链接时）被编译为位置无关代码(Position Independent Code，PIC)，这样它们才能被安全地加载到内存中的任何可用地址**，以实现“多进程共享”：如果内存中尚无此库，则加载；如果已有，则多个程序将共享同一份代码副本。

加载完成后，**加载器会执行**运行时的符号解析**，将程序中的函数调用存根连接到库在内存中的实际地址。以及地址重定位**，即将程序中对函数的“模糊”调用，修正为指向库代码在内存中的“确切”物理地址。最终，在内存中构建出一个完整的程序镜像，准备交由 CPU 执行。

动态加载时的常见错误是在**运行时**，操作系统的“动态加载器 (Loader)”**无法**在它的标准搜索路径（如 `/usr/lib`, `/lib`）中找到动态库文件（ `libmymath.so`）因为你可能把动态库放在了其他地方。

可以看到，运行时的‘动态加载’得以实现，其前提是构建时的链接阶段的准备：链接器(Linker) 必须先在可执行文件中写入‘引用标记’，加载器(Loader) 才能在运行时解析**这些标记并加载动态库**。

# scene 8 动态库/链接

现在来演示一下具体的静态库链接实操。（人）

首先编译源代码为.o目标文件 ，这一步与静态库类似，但**必须**添加 `-fPIC` 标志。其中的PIC就是前面介绍的Position Independent Code，它告诉编译器构建阶段生成的代码不要依赖于它被加载到内存中的绝对地址。这是动态库必须的要求，因为它在运行时可能被加载到任何可用的内存位置，具体细节可参见我的内存布局视频中的ASLR。

```
g++ -c -fPIC my_add.cpp my_multiply.cpp
```

接着，由目标文件.o创建动态库。这一步不再是 `ar` 命令，而是使用 `g++`的  `-shared` 标志。动态库名称的标准命名规范是 `lib<name>.后缀`。注意：动态库的后缀是平台相关的（macOS 为 `.dylib`，Linux 为 `.so`，Windows 为 `.dll`）。

```
g++ -shared -o libmymath.dylib my_add.o my_multiply.o
```

**现在目录中会生成动态库** `libmymath.dylib` ，这里是macOS平台。

然后编译主程序得到 `main.o`，这一步和静态库完全相同。

```
g++ -c main.cpp
```

最后，链接 `.o` 文件和动态库。这一步只是在可执行文件中记录引用。命令中的**`-L.`**告诉链接器在 `.` (当前目录) 搜索库。**`-lmymath`**则是告诉链接器链接标准命名为 `mymath`的动态库。这里的小l表示跨平台的快捷方式，动态库比静态库更需要规范命名，因为静态库在不同平台都是.a后缀而动态库则具有不同的后缀（`.dylib`，.so，`.dll`）。这种平台无关性是自动化构建系统（如 CMake）的基础。

```
g++ main.o -L. -lmymath -o my_program_dynamic
```

现在目录中会生成执行体 `my_program_dynamic`且可以正确运行。

```
rm *.o && ./my_program_dynamic
```

**注意：** 此时的可执行文件`my_program_dynamic` **不包含** `add` 和 `multiply` 的代码，只包含一个“便条”，写着“运行时需要加载 `libmymath.dylib`”。

现在我们来证明其是在运行时才被加载的，删掉当前目录的libmymath.dylib。

```
rm libmymath.dylib
```

再次运行 `./my_program_dynamic`，就会失败报错，因为运行时的加载阶段找不到动态库。

```
./my_program_dynamic
```

也可以在macOS上使用 `otool -L my_program_dynamic`查看某个执行体依赖的动态库，Linux上则对应是ldd my_program_dynamic命令，其中ldd是**L**ist **D**ynamic **D**ependencies的缩写。

```
otool -L my_program_dynamic  # MacOS
```





# scene 9 静态 vs 动态 

通过以上代码实例，可以发现同一套源代码既可以选择静态链接也可以选择动态链接。它们在程序生命周期上的核心区别仅仅在于**何时**（When）解析代码。

 **静态链接**在**链接时 (Link-Time)**将依赖库的代码实现嵌入到最终的可执行文件中。**动态链接**在**链接时**仅记录引用标记，直到**运行时 (Run-Time)** 才由操作系统加载器去解析。

静态库和动态库虽然可以相互转换，但这背后是完全不同的软件架构思想。在工程实践中，选择静态还是动态，本质上是在“**部署隔离性**”与“**维护灵活性**”之间做出权衡。

当你的核心诉求是交付一个**完全自包含、环境隔离的单一可执行文件**时，应选择静态链接。静态链接将所有依赖的代码“复印”到你的程序中，确保程序在任何目标机器上都能以完全可预测的方式运行。这非常适用于 Docker 容器或分发给用户的简单命令行工具。

静态链接**就像一个内嵌了所有数据的文档**，接收者无需任何额外操作即可阅读。但缺点是文件体积大，且如果原始数据（库）更新了，接收者手上的这份文档（程序）并不会自动更新。

当您的核心诉求是节省资源和灵活维护时，应选择动态链接。它允许多个程序共享同一份物理内存中的库代码（节省资源），此外，它允许开发者**独立更新**库（例如修复安全漏洞）而无需重新编译主程序，甚至可以通过插件机制动态扩展功能。

动态链接**就像一个包含超链接的文档**：文件本身很小，链接的内容也永远是最新版本。但缺点也很明显：如果“超链接”失效（即依赖丢失），或者链接的层级过深（即依赖地狱），文档（程序）就无法正常工作了。



# scene 10 自动化构建系统

在前面展示的代码实例中，虽然只有项目中只有几个文件，但我们已经体会到了重复和繁琐的命令行手动构建过程。

想象一个有成百上千个源文件、需要链接十几个第三方库、还要在 Windows、Linux 和 macOS 上都能运行的大型项目，手动管理这个过程是几乎不可能的。

对于现代 C/C++ 开发，也必须采用更为现代的自动化构建系统，**CMake** 因此应运而生。

只需要编写一个名为 `CMakeLists.txt` 的文本，就可以把一切代码跨平台地进行构建。CMake 本身**并不是构建工具**，它是一个**构建生成器 (Build Generator)**。CMake会根据当前的操作系统，**自动生成**平台专属的“真正”构建文件：

- 在 Linux 上，它会生成 `Makefile`。
- 在 Windows 上，它会生成 Visual Studio 的 `.sln` 项目文件。
- 在 macOS 上，它会生成 `Xcode` 项目文件。

在前面介绍的代码案例中，完全可以使用cmake一劳永逸，对名称为StaticDemo开头的子目录自动创建静态库，对DynamicDemo_X子目录自动创建动态库，CMake 将会处理所有那些繁琐、易错、且跨平台不兼容的底层命令。最终所创建的动态库、静态库以及可执行文件，都会在 `cmake-build-debug` 这样的“构建目录”中被**统一生成和管理**。Cmake让我们从“**如何构建**”的泥潭中解放出来，只需专注于“**构建什么**”，实现真正意义上的**跨平台构建**。

至此，我们已经完全了解了C/C++程序的一生，学习这些从构建到运行的底层知识，不是为了记住 `-fPIC` 或 `-L` 这种类似于咒语的命令，这种单纯的记忆，在AI时代价值甚微。而是为了理解：开发者作为造物主，是如何在“灵活性”与“稳定性”、“共享”与“隔离”这些永远绕不开的矛盾中，去寻找那个最精妙的平衡点。

这是软件工程的哲学，也是C++的艺术。

